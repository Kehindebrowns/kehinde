{"ast":null,"code":"'use strict';\n\nvar Transform = require('readable-stream').Transform;\n\nvar isNode = require('detect-node');\n\nvar PADDING = '--';\nvar NEW_LINE = '\\r\\n';\nvar NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\n\nclass Multipart extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    }));\n    this._boundary = this._generateBoundary();\n    this._files = [];\n    this._draining = false;\n  }\n\n  _flush() {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n    this.push(null);\n  }\n\n  _generateBoundary() {\n    var boundary = '--------------------------';\n\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n\n    return boundary;\n  }\n\n  _transform(file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file);\n      return callback(); // early\n    } // not a buffer, must be a file\n\n\n    this._files.push(file);\n\n    this._maybeDrain(callback);\n  }\n\n  _maybeDrain(callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true;\n\n        var file = this._files.shift();\n\n        this._pushFile(file, err => {\n          this._draining = false;\n\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this._maybeDrain(callback);\n          }\n        });\n      } else {\n        this.emit('drained all files');\n        callback();\n      }\n    } else {\n      this.once('drained all files', callback);\n    }\n  }\n\n  _pushFile(file, callback) {\n    var leading = this._leading(file.headers || {});\n\n    this.push(leading);\n    var content = file.content || Buffer.alloc(0);\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content);\n      this.push(NEW_LINE_BUFFER);\n      return callback(); // early\n    } // From now on we assume content is a stream\n\n\n    content.once('error', this.emit.bind(this, 'error'));\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER);\n      callback(); // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    });\n    content.on('data', data => {\n      var drained = this.push(data); // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n\n      if (!drained && isNode) {\n        content.pause();\n        this.once('drain', () => content.resume());\n      }\n    });\n  }\n\n  _leading(headers) {\n    var leading = [PADDING + this._boundary];\n    Object.keys(headers).forEach(header => {\n      leading.push(header + ': ' + headers[header]);\n    });\n    leading.push('');\n    leading.push('');\n    var leadingStr = leading.join(NEW_LINE);\n    return Buffer.from(leadingStr);\n  }\n\n}\n\nmodule.exports = Multipart;","map":{"version":3,"sources":["/workspace/dtube/node_modules/ipfs-http-client/src/utils/multipart.js"],"names":["Transform","require","isNode","PADDING","NEW_LINE","NEW_LINE_BUFFER","Buffer","from","Multipart","constructor","options","Object","assign","objectMode","highWaterMark","_boundary","_generateBoundary","_files","_draining","_flush","push","boundary","i","Math","floor","random","toString","_transform","file","encoding","callback","isBuffer","_maybeDrain","length","shift","_pushFile","err","emit","once","leading","_leading","headers","content","alloc","bind","on","data","drained","pause","resume","keys","forEach","header","leadingStr","join","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Transform = require('readable-stream').Transform\nconst isNode = require('detect-node')\n\nconst PADDING = '--'\nconst NEW_LINE = '\\r\\n'\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE)\n\nclass Multipart extends Transform {\n  constructor (options) {\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 1 }))\n\n    this._boundary = this._generateBoundary()\n    this._files = []\n    this._draining = false\n  }\n\n  _flush () {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE))\n    this.push(null)\n  }\n\n  _generateBoundary () {\n    var boundary = '--------------------------'\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16)\n    }\n\n    return boundary\n  }\n\n  _transform (file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file)\n      return callback() // early\n    }\n    // not a buffer, must be a file\n    this._files.push(file)\n    this._maybeDrain(callback)\n  }\n\n  _maybeDrain (callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true\n        const file = this._files.shift()\n        this._pushFile(file, (err) => {\n          this._draining = false\n          if (err) {\n            this.emit('error', err)\n          } else {\n            this._maybeDrain(callback)\n          }\n        })\n      } else {\n        this.emit('drained all files')\n        callback()\n      }\n    } else {\n      this.once('drained all files', callback)\n    }\n  }\n\n  _pushFile (file, callback) {\n    const leading = this._leading(file.headers || {})\n\n    this.push(leading)\n\n    let content = file.content || Buffer.alloc(0)\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content)\n      this.push(NEW_LINE_BUFFER)\n      return callback() // early\n    }\n\n    // From now on we assume content is a stream\n    content.once('error', this.emit.bind(this, 'error'))\n\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER)\n      callback()\n\n      // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    })\n\n    content.on('data', (data) => {\n      const drained = this.push(data)\n      // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n      if (!drained && isNode) {\n        content.pause()\n        this.once('drain', () => content.resume())\n      }\n    })\n  }\n\n  _leading (headers) {\n    var leading = [PADDING + this._boundary]\n\n    Object.keys(headers).forEach((header) => {\n      leading.push(header + ': ' + headers[header])\n    })\n\n    leading.push('')\n    leading.push('')\n\n    const leadingStr = leading.join(NEW_LINE)\n\n    return Buffer.from(leadingStr)\n  }\n}\n\nmodule.exports = Multipart\n"]},"metadata":{},"sourceType":"script"}